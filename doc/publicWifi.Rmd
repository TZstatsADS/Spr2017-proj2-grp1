---
title: 'Project 2: Seamless Public WiFi'
author: 'Group 1: Xuehan Liu, Zhilin Fan, Vikas Arun, Ken Chew, Sean Reddy'
date: "February 20, 2017"
output:
  pdf_document: default
  html_notebook: default
---

```{r}
data1 <- read.csv("../data/Free_WiFi_Hotspots_09042005.csv", header=TRUE)
data2 <- read.csv("../data/LinkNYC_Locations.csv", header=TRUE)

data_c1 <- cbind(data1$LON, data1$LAT, data1$SSID)
data_c2 <- cbind(data2$Longitude, data2$Longitude, data2$CB.Link.ID)

library(dismo)
library(sp)
library(geosphere)
library(ggplot2)
library(ggmap)
library(rgeos)
library(scales)


```

```{r eval=FALSE}

### Ignore this section for now

consumerKey = "l_rSuqvu8nD49nJ7Y3uGKw"
consumerSecret = "AZA-PdWtTt2PCTK5SFp792LGHUI"
token = "	tzJ8ZyDR2jeAm4SAEMOkJJe5gFPOkwBl"
token_secret = "e89np3uLyLE5ffunidczgL_HpRY"

require(httr)
require(httpuv)
require(jsonlite)
# authorization
myapp <- oauth_app("YELP", key=consumerKey, secret=consumerSecret)
sig <- sign_oauth1.0(myapp, token=token,token_secret=token_secret)

limit <- 40

# or 10 bars by geo-coordinates
yelpurl <- paste0("https://api.yelp.com/v3/businesses/search?limit=",limit,"&term=starbucks&location=New+York%2C+NY")

locationdata <- GET(yelpurl, sig)
locationdataContent <- content(locationdata)
locationdataList <- jsonlite::fromJSON(toJSON(locationdataContent))
q <- head(data.frame(locationdataList))

q$error.description
```

```{r}
require(httr)
require(httpuv)
require(jsonlite)
require(base64enc)

# Your credentials, from https://www.yelp.com/developers/manage_api_keys
consumerKey = "l_rSuqvu8nD49nJ7Y3uGKw"
consumerSecret = "AZA-PdWtTt2PCTK5SFp792LGHUI"
token = "	tzJ8ZyDR2jeAm4SAEMOkJJe5gFPOkwBl"
token_secret = "e89np3uLyLE5ffunidczgL_HpRY"

yelp_query <- function(path, query_args) {
  # Use OAuth to authorize your request.
  myapp <- oauth_app("YELP", key=consumerKey, secret=consumerSecret)
  sig <- sign_oauth1.0(myapp, token=token, token_secret=token_secret)

  # Build Yelp API URL.
  scheme <- "https"
  host <- "api.yelp.com"
  yelpurl <- paste0(scheme, "://", host, path)

  # Make request.
  results <- GET(yelpurl, sig, query=query_args)

  # If status is not success, print some debugging output.
  HTTP_SUCCESS <- 200
  if (results$status != HTTP_SUCCESS) {
      print(results)
  }
  return(results)
}

yelp_search <- function(term, location, limit=10) {
  # Search term and location go in the query string.
  path <- "/v2/search"
  query_args <- list(term=term, location=location, limit=limit)

  # Make request.
  results <- yelp_query(path, query_args)
  return(results)
}

yelp_business <- function(business_id) {
  # Business ID goes in the path.
  path <- paste0("/v2/business/", business_id)
  query_args <- list()

  # Make request.
  results <- yelp_query(path, query_args)
  return(results)
}

print_search_results <- function(yelp_search_result) {
  print("=== Search Results ===")
  # Load data.  Flip it around to get an easy-to-handle list.
  locationdataContent = content(yelp_search_result)
  locationdataList=jsonlite::fromJSON(toJSON(locationdataContent))

  # Print output.
  print(head(data.frame(locationdataList)))
}

print_business_results <- function(yelp_business_result) {
  print("=== Business ===")
  print(content(yelp_business_result))
}

demo <- function(searchTerm, neighborhood, borough, limit) {
  
  ### THIS ONLY RETURNS FIRST 40. We will have to implement the built in "offset" to acquire ALL results.
  
  lat <- vector()
  lon <- vector()
  businessName <- vector()
  
  # Query Yelp API, print results.
  yelp_search_result <- yelp_search(term=tolower(searchTerm), location=paste0(neighborhood, ", " , borough,", NY"), limit=limit)

  # Pick the top search result, get more info about it.
  # Find Yelp business ID, such as "giacomos-ristorante-boston".
  #business_id = content(yelp_search_result)$businesses[[39]]$id
  #yelp_business_result <- yelp_business(business_id)
  
  numResults <- length(content(yelp_search_result)$businesses)
  
  for (i in 1:numResults){
    lat[i] <- content(yelp_search_result)$businesses[[i]]$location$coordinate$latitude
    lon[i] <- content(yelp_search_result)$businesses[[i]]$location$coordinate$longitude
    businessName[i] <- content(yelp_search_result)$businesses[[i]]$name
  }

  df <- as.data.frame(cbind(lon, lat, businessName))
  colnames(df) <- c("LON", "LAT", "name")
  
  return(df)
  

}

nbh <- read.csv("../data/neighborhoods.csv", header=TRUE)

allStarbucks <- allMcDonalds <- otherWifi <- vector()

for (borough in 1:dim(nbh)[2]){
  borough_name <- colnames(nbh)[borough]
  for (neigh in 1:dim(nbh)[1]){
    
    neigh_name <- nbh[neigh, borough]
    if (neigh_name != ""){
      allStarbucks <- rbind(allStarbucks, demo("Starbucks", neigh_name, borough_name, 40))
      allMcDonalds <- rbind(allMcDonalds, demo("McDonalds", neigh_name, borough_name, 40))
      otherWifi <- rbind(otherWifi, demo("free wifi", neigh_name, borough_name, 40))
    }
    
  }
}

allStarbucks <- unique(allStarbucks)
allMcDonalds <- unique(allMcDonalds)
otherWifi <- unique(otherWifi)
allStarbucks <- allStarbucks[allStarbucks$name == "Starbucks",]
allMcDonalds <- allMcDonalds[allMcDonalds$name == "McDonald's",]
row.names(allStarbucks) <- 1:nrow(allStarbucks)
row.names(allMcDonalds) <- 1:nrow(allMcDonalds)
row.names(otherWifi) <- 1:nrow(otherWifi)

rest_pubWifi <- rbind(allStarbucks,allMcDonalds,otherWifi)
colnames(rest_pubWifi) <- c("LON", "LAT", "network")

```

```{r}

data_c <- as.data.frame(rbind(data_c1, data_c2, as.matrix(rest_pubWifi)))
colnames(data_c) <- c("LON", "LAT", "network")

```



```{r}

library(raster)
library(rgeos)

# Load in Taxi Data
url <-"https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2016-02.csv"
data <- read.csv(url, header=TRUE, as.is=TRUE)

# Clean up taxi data by using both pickup/dropoff, removing empty coordinates, and removing likely erroneous coordinates.
pts <- as.data.frame(cbind(data$pickup_longitude, data$pickup_latitude, data$tpep_pickup_datetime))
colnames(pts) <- c("LON", "LAT", "TIME")
pts2 <- as.data.frame(cbind(data$dropoff_longitude, data$dropoff_latitude, data$tpep_dropoff_datetime))
colnames(pts2) <- c("LON", "LAT", "TIME")
pts3 <- as.data.frame(rbind(pts,pts2))
pts3$LON <- as.numeric(as.character(pts3$LON))
pts3$LAT <- as.numeric(as.character(pts3$LAT))
pts4 <- pts3[(pts3$LAT != 0) & (pts3$LON != 0),]
pts5 <- pts4[(pts4$LAT >= 38) & (pts4$LAT <= 44) & (pts4$LON <= -72) & (pts4$LON >= -76),]
pts6 <- pts5[1:500000,]

nycShapeFile <- shapefile("../data/nynta_16d/nynta.shp")

source("../doc/identifyNeighborhoodsAndBoroughs.R")
pts7 <- identifyNeighborhoodsAndBoroughs(pts6, nycShapeFile)

```

```{r}
# Convert neighborhoods to old naming convention
nbh <- read.csv("../data/neighborhoods.csv", header=TRUE)
centroidLocations <- centrLoc <- read.csv("../output/neighborhood_centroids_latlong.csv", header=TRUE)
colnames(centroidLocations) <- colnames(centrLoc) <- c("borough", "neighborhood", "LAT", "LON", "neighborhoodID")

centroidMapping <- identifyNeighborhoodsAndBoroughs(centrLoc, nycShapeFile)

getApproxOldName <- function(mapped_name){
  oldName <- centroidMapping$neighborhood[centroidMapping$mapped_neighborhood == mapped_name][1]
  return(oldName)
}

pts7$neighborhood <- sapply(pts7$mapped_neighborhood, getApproxOldName)

pts8 <- pts7[complete.cases(pts7),]
colnames(pts8)[5] <- "borough"
```

```{r}
# Plot heatmaps of yelp and taxi data
library(ggmap)
source("../doc/createHeatMap.R")
taxiHeatMap <- createHeatMap(neighborhood="Alphabet City", "Manhattan", pts8, "red")
taxiHeatMap

yelpdata <- read.csv("../output/yelpdata.csv", header=TRUE)
yelpHeatMap <- createHeatMap(neighborhood ="Alphabet City", "Manhattan", yelpdata, "blue")
yelpHeatMap
```
